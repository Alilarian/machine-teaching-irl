import numpy as np
from utils import atom_to_constraints

def scot_greedy_family_atoms_tracked(
    U_global,
    atoms_per_env,
    SFs,
    envs,
    *,
    normalize=True,
    round_decimals=12,
):
    """
    Greedy SCOT selection over atomic feedback across multiple environments.
    
    SCOT selects atoms that collectively cover the largest portion of the
    universal constraint set U_global. Each atom produces one or more
    linear constraint vectors via successor features.

    Parameters
    ----------
    U_global : np.ndarray (N, d)
        Universal constraint set (Q-based + atom-based), already deduplicated.
    atoms_per_env : list[list]
        atoms_per_env[i] = list of candidate atoms from environment i.
    SFs : list of tuples
        Successor feature structures; only mu_sa is used.
    envs : list
        Environment objects corresponding to each atom group.
    normalize : bool
        Normalize constraint vectors before hashing.
    round_decimals : int
        Decimal precision when hashing constraint vectors.

    Returns
    -------
    chosen : list of (env_idx, atom)
        Atoms selected by SCOT in greedy order.
    env_stats : dict
        Per-environment info: atoms chosen, iteration index,
        coverage count, and total contributed coverage.
    chosen_constraints : np.ndarray (M, d)
        All constraint vectors generated by the selected atoms,
        stacked into a single matrix.
    """
    U_global = np.asarray(U_global)
    # ------------------------------------------------------------
    # Utility: normalize & hash constraint vectors
    # ------------------------------------------------------------
    def key_for(v):
        n = np.linalg.norm(v)
        if n == 0.0 or not np.isfinite(n):
            return ("ZERO",)
        vv = v / n if normalize else v
        return tuple(np.round(vv, round_decimals))

    # ------------------------------------------------------------
    # Create mapping: hash_key â†’ indices in U_global
    # ------------------------------------------------------------
    key_to_uix = {}
    for idx, v in enumerate(U_global):
        key_to_uix.setdefault(key_for(v), []).append(idx)

    universe = set(range(len(U_global)))
    covered = set()

    chosen = []
    chosen_constraints_list = []

    # ------------------------------------------------------------
    # Per-environment stats
    # ------------------------------------------------------------
    env_stats = {
        i: {
            "atoms": [],
            "indices": [],
            "coverage_counts": [],
            "total_coverage": 0,
        }
        for i in range(len(atoms_per_env))
    }

    # ------------------------------------------------------------
    # Precompute coverage sets per atom
    # ------------------------------------------------------------
    cov = []
    for env_idx, (atom_list, sf, env) in enumerate(zip(atoms_per_env, SFs, envs)):

        mu_sa = sf[0]
        cov_i = []

        for atom in atom_list:
            constraints = atom_to_constraints(atom, mu_sa, env)

            atom_cov = set()
            for v in constraints:
                k = key_for(v)
                if k in key_to_uix:
                    atom_cov.update(key_to_uix[k])

            cov_i.append(atom_cov)

        cov.append(cov_i)

    # ------------------------------------------------------------
    # SCOT greedy set cover
    # ------------------------------------------------------------
    iter_count = 0

    while True:
        uncovered = universe - covered
        if not uncovered:
            break

        best_gain = 0
        best_atom = None
        best_new = None

        for env_idx in range(len(atoms_per_env)):
            for atom_idx, atom_cov in enumerate(cov[env_idx]):

                if not atom_cov:
                    continue

                new_cover = uncovered & atom_cov
                gain = len(new_cover)

                if gain > best_gain:
                    best_gain = gain
                    best_atom = (env_idx, atom_idx)
                    best_new = new_cover

        if best_atom is None:
            break

        env_idx, atom_idx = best_atom
        atom = atoms_per_env[env_idx][atom_idx]

        # Recompute constraint vectors for the selected atom
        mu_sa = SFs[env_idx][0]
        constraints_for_atom = atom_to_constraints(atom, mu_sa, envs[env_idx])
        chosen_constraints_list.append(np.array(constraints_for_atom))

        chosen.append((env_idx, atom))
        covered |= best_new

        # Update per-env stats
        env_stats[env_idx]["atoms"].append(atom)
        env_stats[env_idx]["indices"].append(iter_count)
        env_stats[env_idx]["coverage_counts"].append(len(best_new))
        env_stats[env_idx]["total_coverage"] += len(best_new)

        iter_count += 1

    # ------------------------------------------------------------
    # Concatenate all chosen constraint vectors
    # ------------------------------------------------------------
    if chosen_constraints_list:
        d = U_global.shape[1]
        chosen_constraints = np.vstack(chosen_constraints_list)
    else:
        chosen_constraints = np.zeros((0, U_global.shape[1]))

    return chosen, env_stats, chosen_constraints
## how many envs got activated
## each env 
## we can provide some examples whereE-stop is more informative than others. specifically env without terminals
## but in expectation story is different